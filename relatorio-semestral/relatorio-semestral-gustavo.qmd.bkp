--- 
title: "Relatório Semestral"
bibliography: references.bib
csl: associacao-brasileira-de-normas-tecnicas.csl
lang: pt

authors:
  - name: "Orientando: Gustavo Silva Garone"
  - name: "Orientadora: Elisabeti Kira"

date: "Fevereiro de 2025"
format:
  pdf:
    documentclass: article
    fontsize: 12pt
    monofont: "Consolas"
    geometry: "margin=1in"
    include-in-header:
      text: |
        \usepackage{authblk}
---

# PASSEIO ALEATÓRIO: SIMULAÇÕES PARA VALIDAÇÃO DE MODELOS

## Introdução

Numa versão simples do jogo original proposto por Pascal [@edwards_pascals_1983], dois jogadores, A e B,
competem apostando no lançamento de uma moeda honesta. Ao ganhar a aposta, o jogador A recebe um real
do jogador B e vice-versa, descrevendo um martingal [@doyle_random_1984 p. 11 – 14]. Além da questão proposta por Pascal sobre a
probabilidade do jogador ir à ruína, ou seja, perder todo seu dinheiro, dado que começou com uma quantia $a$, também
foram estudados o tempo esperado de duração do jogo [@stern_conditional_1975] e, pelo cálculo de equações de diferenças
finitas, a variância dessa duração [@andel_variance_2012]. Todavia, os resultados obtidos por esses autores funcionam apenas
para ganho e perda de um real por aposta. 

Neste projeto, realizado conjuntamente com Eduardo Ishihara, analisamos um estimador proposto por este para
passeios aleatórios com regras mais complexas de ganho e perda através do emprego dessas simulações na linguagem de
programação Julia. A descrição desses passeios e de suas diferenças quando comparados a uma forma simples do problema
clássico da Ruína do Jogador será apresentada ao longo do corpo do texto.

Para isto, empregamos o método de Monte Carlo. A Simulação de Monte Carlo é uma técnica baseada em amostragem aleatória
para emular sistemas complexos, normalmente por meios computacionais [@harrison_introduction_2010].
Dessa forma, é útil no estudo do comportamento de passeios aleatórios com parâmetros diversos. Sendo assim,
foi crucial na avalição do estimador proposto uma vez que, como elaborado por Ishihara, replicar as técnicas e cálculos para jogos
mais complexos nem sempre é possível.

## Atividades Desenvolvidas

### Caracterização dos jogos

Varios parâmetros afetam o comportamento de passeios desse tipo. Formalizando o problema da Ruína do Jogador simples,
podemos descrever a variável aleatória $X$ que caracteriza as regras de ganho e perda do jogo.

$$
X = \begin{cases}
1 \text{ (Ganho) } & P(X=1) = 0.5 \\
-1 \text{ (Perda) } & P(X=-1) = 0.5
\end{cases}
$$ {#eq-var-x}

Com isso, qualquer jogo pode ser descrito pelo valor inicial do jogador A $a$, o valor total em aposta $N$ e suas regras
$X$. Também é possível qualquer jogo ocorrido com esse mesmo recurso, empregando um vetor dos valores assumidos por $X$,
$\pmb{x} = (x_1, x_2, \dots, x_t)$ onde $t$ é a duração total do jogo.


### Proposta do estimador

Usando os resultados de @stern_conditional_1975, temos a esperança da duração $T$ de um jogo iniciado com saldo $a, \mu_a = E(T_a)$

$$
\begin{aligned}
\mu_a = E(T_a) = \left\{ \begin{array}{cc}
a(N - a) & \mathbf{se}\ p = q = 1/2, \\
\frac{a}{q - p} - \frac{N}{q - p} \left( \frac{1 - (q/p)^a}{1 - (q/p)^N} \right) & \mathbf{se}\ p \neq q.
\end{array} \right.
\end{aligned}
$$ {#eq-original}

Vamos considerar um passeio com a chance de ganhar $p=0.4, q = 1-p$, o início $a=30$ e dinheiro total em aposta entre os dois jogadores (final) $N=100$.
De ([-@eq-original]), temos que
$$
\mu_a = \frac{30}{0.2} - \frac{100}{0.2} \left(\frac{1 - (0.6/0.4)^{30}}{1 - (0.6/0.4)^{100}} \right) \approx 150
$$

Utilizando o estimador proposto por Ishihara
$$
\widehat{E}(T_a) = \left\{\begin{array}{cc}
\frac{N-a}{p-q} & \mathbf{se}\ p > q \\
\frac{a}{q-p} & \mathbf{se}\ p < q
\end{array}\right.
$$ {#eq-estimador-simples}

Para $q\neq p$, temos $\frac{30}{0.2}=150$. O que condiz com os resultados teóricos.

### Aplicações em casos com regras diferentes

Por si só, o resultado acima não diz muito sobre o estimador, uma vez que este pode conferir pelo pequeno valor de
$\left( \frac{1 - (q/p)^a}{1 - (q/p)^N} \right)$ em ([-@eq-original]). Então, testamos casos em que ([-@eq-original])
deixou de funcionar.

Adaptando ([-@eq-estimador-simples]), podemos trocar o denominador por uma esperança calculada com base nas regras do jogo.
Seja X a variável aleatória que define as regras de ganho e perda em cada jogada:
$$
X = \begin{cases}
\text{ganho em reais}, \text{ com probabilidade } p \\
\text{perda em reais}, \text{ com probabilidade } q = 1-p \\
\end{cases}
$$ {#eq-var-x}

Com esse recurso, podemos expandir o estimador ([-@eq-estimador-simples]) para funcionar com jogos mais complexos.

Um desses jogos foi uma simples variação do jogo anterior, ainda com $p = 0.4, q = 1-p, a = 30$ e $N=100$, fizemos
o apostador ganhar R\$2,00 por vitória, mas ainda perder apenas R\$1,00 por derrota. Nesse caso, temos substituindo em ([-@eq-var-x])
nossa variável de regras X,
$$
X = \begin{cases}
2, \text{ com probabilidade } 0.4 \\
-1, \text{ com probabilidade } 0.6 \\
\end{cases}
$$ {#eq-var-x-jogo}

E a versão expandida do estimador
$$
\widehat{E}(T_a) = \left\{ \begin{array}{cc}
\frac{N-a}{E(X)} & \mathbf{se}\ E(X) > 0 \\
\left\lvert\frac{a}{E(X)}\right\rvert & \mathbf{se}\ E(X) < 0
\end{array}\right.
$$ {#eq-estimador-expandido}

Desenvolvemos algoritmos de simulação baseados no método de Monte Carlo para testar o estimador. A primeira versão do algoritmo,
implementada em Python, não satisfez as demandas de tempo e complexidade que desejávamos. Para solucionar essa limitação, migramos
para a linguagem Julia, com velocidade computacional competitiva com o C [@godoy_evaluating_2023], conhecida por sua alta eficiência
característica da operação em baixo nível. Assim, conseguimos rodar um número maior de simulações em tempo razoável para melhorar a
acurácia dos resultados [@ritter_determining_2011].

Chamaremos de $\bar{\psi}_M$ a média das durações dos $M$ passeios simulados. Confere que
$\bar{\psi}_M\stackrel{M \rightarrow \infty}{\rightarrow} E(T_a)$. Isto é, os valores simulados se aproximam
da esperança de duração conforme o número de simulações $M$ cresce.

Os métodos utilizados para derivar ([-@eq-original]), como observado por Eduardo, não funcionam ou são muti difíceis 
$\bar{\psi}_M \approx 350$
(veja o Apêndice A para o código dessa simulação assim como uma comparação entre as linguagens Julia e Python). 

Considerando que $E(X) = 0.2$, Aplicando o estimador expandido ([-@eq-estimador-expandido]), temos que
$$
\widehat{E}(T_a) = \frac{70}{0.2} = 350
$$

Durante o desenvolvimento dos algoritmos, introduzimos novas regras ao jogo para testarmos a flexibilidade do estimador.
Nas primeiras simulações, definimos que o jogador A ganhava $1$ real com probabilidade $\frac{1}{3}$, ganhava $3$
reais com probabilidade $\frac{1}{3}$ e perdia $1$ real com probabilidade $\frac{1}{3}$. Com $a=30, N = 100$, temos
as simulações (Apêndice B), que $\bar{\psi}_M \approx 70.7$. Nessa configuração, $E(X) = 1$ e, pelo estimador,
$\widehat{E}(T_a) = \frac{100-30}{1}=70$.

Testamos o estimador sob diferentes regras e, na maioria dos casos, mostrou forte concordância com
os valores simulados. Isso destaca a vantagem do estimador: estimar a duração de um jogo com regras
diversas, o que, até onde encontramos na literatura, não foi descrito apenas com desenvolvimento teórico em probabilidade.

Estudamos também como simplificar a variável aleatória de regras $X$ através de médias quando esta pode assumir mais
que dois valores.

O ponto fraco do estimador atualmente reside nas regras que levam a $E(X)$ próximo de $0$, uma vez que, conforme $E(X)$
se aproxima de $0$, descrevendo o passeio como um martingal, sua presença no denominador provoca divergências quando
comparado com o valor simulado.


```{julia}
#| echo: false
#| fig-env: figure
#| fig-cap: Comparação entre o estimador e simulações
using  Plots, LaTeXStrings, Random
Random.seed!(2)
x = [+2, -1]
a = 30
N = 100
function estimador(p)
  esp = x[1] * p + x[2] * (1-p)
  if esp >= 0
    return (N-a) / esp
  else
    return abs(a / esp)
  end
end

function simulador(p)
  M = 10000
  duracoesSoma = 0
  for i in 1:M  
    saldo = a
    duracao = 0
    while saldo > 0 && saldo < N
      if p > rand()
        saldo += 2
      else
        saldo -= 1
      end
      duracao += 1
    end
    duracoesSoma += duracao
  end
  return duracoesSoma / M
end

function main()
  simulados = [] 
  estimados = []
  alcance = 0.001:0.001:0.999
  for p in alcance
    append!(simulados, simulador(p))
    append!(estimados, estimador(p))
  end
  diferencas = abs.(simulados-estimados)

  simulacoes = plot(alcance, simulados, label="", ylabel=L"\bar{\psi}_M",
                    title="Média dos passeios simulados",
                    ylim=(0,1.1 * maximum(simulados)))
  vline!([0.34], label=L"E(X)=0")
  estimacoes = plot(alcance, estimados, label="", ylabel=L"\widehat{E}(T_a)",
                    title="Valor estimado", ylim=(0, 1.3*maximum(simulados)))
  vline!([0.34], label=L"E(X)=0")
  diferenca = plot(alcance, diferencas, label="", ylabel=L"|\widehat{E}(T_a)" *
                     L" - \bar{\psi}_M|", title="Diferença entre valor" *
                     " estimado e simulado", ylim=(0, 1.1*maximum(simulados)))
  vline!([0.34], label=L"E(X)=0")
  analise = plot(simulacoes, estimacoes, diferenca, xlabel=L"p",
                 titlefontsize = 8, layout=(3,1),
                 plot_title=LaTeXString(
"\$^{a = 10, N = 100, X = \\{+2, -1\\}, p \\textrm{\\ variando\\ } 0.001 \\textrm{\\ em\\ } (0,1)}\$"),
                 tickfont=6)
  display(analise)
end
main()
```

## Conclusão e Passos Seguintes

Os resultados obtidos indicam que o estimador proposto possui grande flexibilidade para diferentes configurações do jogo
e mostra-se especialmente útil, pois as técnicas atuais não são capazes de fornecer um resultado teórico exato para as
configurações de jogos propostas. Ademais, o estimador fornece estimativas mais precisas quando há maior circulação de
dinheiro entre os jogadores. No entanto, observamos que o estimador tende a divergir rapidamente dos resultados simulados
quando a esperança da variável aleatória que rege as regras do jogo aproxima-se de zero devido ao denominador.

Outro desafio identificado foi a complexidade computacional envolvida na simulação de jogos com muitas regras, isto é,
quando a variável aleatória pode assumir um grande número de valores. Essa limitação impõe a necessidade de soluções mais
eficientes para lidar com cenários de alta complexidade, o que será um obstáculo a ser superado no estudo do caso não
homogêneo.

Um interessante caminho de abordagem que buscaremos explorar é a conexão entre passeios aleatórios e redes elétricas como descrito
por @doyle_random_1984. Queremos descobrir se existem conexões entre o estimador proposto e fórmulas da física, além de outras
abordagens para estudarmos passeios aleatórios, como o emprego de equações de diferenças finitas e o estudo de martingais.

{{< pagebreak >}}

## Bibliografia

::: {#refs}
:::

{{< pagebreak >}}

## Apêndice A - Comparação de um mesmo algoritmo em Julia e Python {.appendix}

Para validar nossa decisão de trocarmos de linguagem, comparamos o mesmo (ingênuo) algoritmo em Julia e Python que usamos
para testar o estimador:

### Julia

```{julia}
using  LaTeXStrings, Random

function main()
  Random.seed!(1)
  duracoesSoma = 0
  M = 1_000_000
  p = 0.4
  teto = 100
  for i in 1:M
    saldo = 30
    duracao = 0
    while saldo > 0 && saldo < teto
      if p > rand()
        saldo += 2
      else
        saldo -= 1
      end
      duracao += 1
    end
    duracoesSoma += duracao
  end
  display(LaTeXString("Média da duração de \$$M\$ passeios:
                      \$$(round(duracoesSoma/M, digits = 2))\$"))
end

tempo = @elapsed main()
display(LaTeXString("Tempo de execução em segundos: $tempo"))
```
{{< pagebreak >}}

### Python

```python
import random
import time


def main():
    random.seed(1)
    duracoes = 0
    M = 1_000_000
    p = 0.4
    teto = 100
    for i in range(M):
        saldo = 30
        duracao = 0
        while saldo > 0 and saldo < teto:
            if p > random.random():
                saldo += 2
            else:
                saldo -= 1
            duracao += 1
        duracoes += duracao
    media = duracoes / M
    print(f"Média da duração de {M} passeios: {media:.2f}")
  

start_time = time.time()
main()
print(f"Tempo de execução: {time.time() - start_time} segundos")
```

```{julia}
#| echo: false

using PyCall, LaTeXStrings

py"""
def simulacao_py():
  import random
  import time

  def main():
      random.seed(1)
      duracoes = 0
      M = 1000000
      p = 0.4
      teto = 100
      for i in range(M):
          saldo = 30
          duracao = 0
          while saldo > 0 and saldo < teto:
              if p > random.random():
                  saldo += 2
              else:
                  saldo -= 1
              duracao += 1
          duracoes += duracao
      return duracoes / M
      # print(f"Média da duração de {M} passeios: {media:.2f}")
    

  start_time = time.time()
  return main()
  # print(f"Tempo de execução: {time.time() - start_time} segundos")
"""
a = @elapsed media = py"simulacao_py"()
display(LaTeXString("Média da duração de \$1000000\$ passeios: \$$(round(media, digits=2))\$"))
display(LaTeXString("Tempo de execução: $a segundos"))
```

Para a simulação em Python nesse artigo, foi utilizado a biblioteca PyCall que nos permite criar um ambiente Python no Julia,
possibilitando rodar código Python nessa linguagem o que foi necessário para inclusão de sua saída exata no relatório.
A performance pode ter sido afetada minimamente nos tempos de chamada ao Kernel de execução do Python.

### Decisão de mudança

Desconsiderando o curto tempo de compilação do tempo total do código em Julia, que só precisa ser
feito uma vez, temos que essa linguagem costuma ser considerávelmente mais rápida do que o Python, o que foi crucial nessas
simulações e justificou nossas mudanças como previsto por resultados anteriores de @godoy_evaluating_2023

## Apêndice B - Código de simulação com regras mais complexas

```{julia}
using LaTeXStrings, Random

function main()
  Random.seed!(1)
  duracoesSoma = 0
  M = 10_000_000
  p1 = 1/3
  p2 = 2/3
  teto = 100
  for i in 1:M
    saldo = 30
    duracao = 0
    while saldo > 0 && saldo < teto
      moeda = rand()
      if moeda < p2
        if moeda < p1
          saldo += 1
        else
          saldo += 3
        end
      else
        saldo -= 1
      end
      duracao += 1
    end
    duracoesSoma += duracao
  end
  display(LaTeXString("Média da duração de $M passeios:
                      \$$(round(duracoesSoma/M, digits = 2))\$"))
end
main()
```


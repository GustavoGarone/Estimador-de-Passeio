--- 
title: "Relatório Semestral"
bibliography: references.bib
csl: associacao-brasileira-de-normas-tecnicas.csl
lang: pt

authors:
  - name: "Orientando: Gustavo Silva Garone"
  - name: "Orientadora: Elisabeti Kira"

date: last-modified
date-format: long
format:
  pdf:
    documentclass: article
    fontsize: 12pt
    monofont: "Consolas"
    geometry: "margin=1in"
    include-in-header:
      text: |
        \usepackage{authblk}
---

# PASSEIO ALEATÓRIO: SIMULAÇÕES E AVALIAÇÃO DE NOVAS ABORDAGENS

## Introdução

Numa versão simples da original proposta por Pascal [@edwards_pascals_1983], dois jogadores, A e B,
competem apostando no lançamento de uma moeda honesta. Ao ganhar a aposta, o jogador A recebe um real
do jogador B e vice-versa. Realizamos uma revisão da literatura existente para identificar os principais resultados sobre o problema
da Ruína do Jogador e suas variações. Além da questão proposta por Pascal sobre a
probabilidade do jogador ir à ruína, ou seja, perder todo seu dinheiro, dado que começou com uma quantia $a$, também
foram estudados o tempo esperado de duração do jogo [@stern_conditional_1975] e, pelo cálculo de equações de diferenças
finitas, a variância dessa duração [@andel_variance_2012], explorando casos em que o jogador B tem dinheiro finito,
fornecendo uma barreira superior para o jogo $N$, e casos em que B age como uma banca, possuindo dinheiro ilimitado
e impossibilitando a "vitória" de A. Nesse contexto, os resultados obtidos por esses autores funcionam apenas
para ganho e perda de um real por aposta. 

Neste projeto, realizado conjuntamente com Eduardo Ishihara, analisamos um estimador proposto por este para
passeios mais complexos através do emprego dessas simulações na linguagem de programação Julia. A descrição desses
passeios e de suas diferenças quando comparados ao problema clássico da Ruína do Jogador será apresentada ao longo do
corpo do texto.

A Simulação de Monte Carlo é uma técnica baseada em amostragem aleatória para emular sistemas complexos, normalmente por
meios computacionais [@harrison_introduction_2010]. Dessa forma, é útil no estudo do comportamento de passeios aleatórios
com parâmetros diversos, o que foi crucial para avaliar o estimador proposto.

## Atividades Desenvolvidas

### Descrevendo jogos

No problema da Ruína do Jogador, além do valor inicial $a$ do primeiro jogador e o dinheiro total em aposta $N$, podemos
empregar uma variável aleatória $X$ para descrevermos o ganho e perda em cada jogada ao longo do processo estocástico
no tempo discreto $T$. Logo

$$
X = \begin{cases}
1, P(X=1) = p \\
-1, P(X=-1) = 1-p = q
\end{cases}
$$

Em que, na Ruína do Jogador, $p = q = 0.5$

Por $X$ a cada instante $t \in T$ (tempo discreto do jogo) não depender de resultados anteriores e $E(X) = 0$, vemos que
esse problema trata de uma cadeia de markov e de um martingal [@doyle_random_1984 p. 11-14]. Com esse $X$, podemos
obter resultados tratando da esperança da duração $T$ de jogos desse tipo em função de $a$ e $N$ @stern_conditional_1975

$$
\begin{aligned}
\mu_{a,N} = E(T_{a,N}) = \left\{ \begin{array}{cc}
a(N - a) & \mathbf{se}\ p = q = 1/2, \\
\frac{a}{q - p} - \frac{N}{q - p} \left( \frac{1 - (q/p)^a}{1 - (q/p)^N} \right) & \mathbf{se}\ p \neq q.
\end{array} \right.
\end{aligned}
$$ {#eq-original}

Temos pelo desenvolvimento desse resultado que ([-@eq-original]) depende da propriedade markoviana e que $\mu_{a,n}$
assume formas diferentes caso o passeio se trate ou não de um martingal.

Como descrito por Ishihara, seguindo os resultados [de @stern_conditional_1975] para outras formas de $X$ mais complexas,
utilizando valores de ganho e perda diferentes de $1$ ou com mais valores possíveis é cada vez mais difícil conforme a
complexidade de $X$ aumenta, inviabilizando a resolução analítica de problemas desse tipo. Portanto, foi proposto um
estimador para avaliação atraveś de simulações de Monte Carlo.

#### Notação para jogos 

Descreveremos jogos (passeios) futuros em termos de $a$, $N$ e $X$, $J_{a,N,X}$, e buscaremos $\mu_J = E(T_J)$ a esperança
da duração do jogo $J$, com $X$ da forma genérica
$$
X = \begin{cases}
x_1, P(X=x_1) = p_1 \\
x_2, P(X=x_2) = p_2 \\
x_3, P(X=x_3) = p_3 \\
\hdots \\
x_k, P(X=x_k) = p_k
\end{cases}
$$ {#eq-var-x}

### Introdução do estimador

O estimador sob avaliação é da seguinte forma
$$
\widehat{E}(T_J) = \left\{ \begin{array}{cc}
\frac{N-a}{E(X)} & \mathbf{se}\ E(X) > 0 \\
\left\lvert\frac{a}{E(X)}\right\rvert & \mathbf{se}\ E(X) < 0
\end{array}\right.
$$ {#eq-estimador}

Consideraremos um passeio $J_{30,100,X}$, com ([-@eq-var-x])
$$
X = \begin{cases}
1, P(X=1) = 0.4 \\
-1, P(X=-1) = 0.6
\end{cases}
$$
De ([-@eq-original]), temos que
$$
\mu_J = \frac{30}{0.2} - \frac{100}{0.2} \left( \frac{1 - (0.6/0.4)^{30}}{1 - (0.6/0.4)^{100}} \right) \approx 150
$$

De ([-@eq-estimador]), como $E(X) = -0.2$, temos $\widehat{E(T_J)} = \frac{30}{0.2}=150$. O que condiz com o resultado téorico.

#### Aplicações em casos com regras diferentes

Passamos a estudar casos em que ([-@eq-original]) deixa de funcionar devido a uma maior complexidade de $X$.

Um desses jogos foi uma simples variação do jogo anterior, $a = 30$ e $N=100$, mas fizemos o apostador ganhar
dois por vitória, ainda perdendo apenas um por derrota. Nesse caso, temos nossa variável de regras X ([-@eq-var-x])
$$
X = \begin{cases}
2, P(X=2) = 0.4 \\
-1, P(X=-1) = 0.6 \\
\end{cases}
$$

E o novo jogo $J_{30, 100, X}$

Uma vez que ([-@eq-original]) não seria apropriada devido a nova forma de $X$, desenvolvemos algoritmos de simulação
baseados no método de Monte Carlo para avaliarmos o estimador. A primeira versão do algoritmo,
implementada em Python, não satisfez as demandas de tempo e complexidade que desejávamos. Para solucionar essa limitação, migramos
para a linguagem Julia, com velocidade computacional competitiva com o C [@godoy_evaluating_2023], conhecida por sua alta eficiência
característica da operação em baixo nível. Assim, conseguimos rodar um número maior de simulações em tempo razoável para melhorar a
acurácia dos resultados [@ritter_determining_2011].

Chamaremos de $\bar{\psi}_{M,J}$ a média das durações dos $M$ passeios $J$ simulados. Confere que
$\bar{\psi}_{M,J}\stackrel{M \rightarrow \infty}{\rightarrow} \mu_J$. Isto é, os valores simulados se aproximam
da esperança de duração conforme o número de simulações $M$ cresce.

Com esse recurso, $\bar{\psi}_{10000,J} \approx 350$
(veja o Apêndice A para o código dessa simulação assim como uma comparação entre as linguagens Julia e Python). 

Considerando que $E(X) = 0.2$, Aplicando o estimador ([-@eq-estimador]), temos que
$$
\widehat{E}(T_J) = \frac{70}{0.2} = 350
$$

o estimador sob diferentes regras e, na maioria dos casos, mostrou forte concordância com
os valores simulados. Isso destaca a vantagem do estimador: estimar a duração de um jogo com regras
diversas, o que, até onde encontramos na literatura, não foi descrito apenas com desenvolvimento analítico.

| $\text{Semente}$ | $E(X)$ | $\widehat{E}(T_J)$ | $\bar{\psi}_{M,J}$ |
|:------:|:------:|:------:|:------:|
| $1$    | $10$    | $12.5$    | $13.14$     |
| $2$    | $5$     | $25$      | $25.44$     |
| $3$    | $3$     | $50$      | $51.14$     |
| $4$    | $0.5$   | $100$     | $101.12$    |
| $5$    | $-3$    | $50$      | $51.14$     |
| $6$    | $-5$    | $16.66$   | $16.66$     |


: Resultados de diferentes passeios com $a=50, N=100$ e $X$ variando {#tbl-simulados}

Note que, como esperado, quanto menor $E(X)$, mais impreciso tende a ser o estimador,
por $1$.

```{julia}
#| echo: false
#| fig-env: figure
#| fig-cap: Comparação entre o estimador e simulações
using  Plots, LaTeXStrings, Random
Random.seed!(2)
x = [+2, -1]
a = 30
N = 100
function estimador(p)
  esp = x[1] * p + x[2] * (1-p)
  if esp >= 0
    return (N-a) / esp
  else
    return abs(a / esp)
  end
end

function simulador(p)
  M = 10000
  duracoesSoma = 0
  for i in 1:M  
    saldo = a
    duracao = 0
    while saldo > 0 && saldo < N
      if p > rand()
        saldo += 2
      else
        saldo -= 1
      end
      duracao += 1
    end
    duracoesSoma += duracao
  end
  return duracoesSoma / M
end

function main()
  simulados = [] 
  estimados = []
  alcance = 0.001:0.001:0.999
  for p in alcance
    append!(simulados, simulador(p))
    append!(estimados, estimador(p))
  end
  diferencas = abs.(simulados-estimados)

  simulacoes = plot(alcance, simulados, label="", ylabel=L"\bar{\psi}_M",
                    title="Média dos passeios simulados",
                    ylim=(0,1.1 * maximum(simulados)))
  vline!([0.34], label=L"E(X)=0")
  estimacoes = plot(alcance, estimados, label="", ylabel=L"\widehat{E}(T_a)",
                    title="Valor estimado", ylim=(0, 1.3*maximum(simulados)))
  vline!([0.34], label=L"E(X)=0")
  diferenca = plot(alcance, diferencas, label="", ylabel=L"|\widehat{E}(T_a)" *
                     L" - \bar{\psi}_M|", title="Diferença entre valor" *
                     " estimado e simulado", ylim=(0, 1.1*maximum(simulados)))
  vline!([0.34], label=L"E(X)=0")
  analise = plot(simulacoes, estimacoes, diferenca, xlabel=L"p",
                 titlefontsize = 8, layout=(3,1),
                 plot_title=LaTeXString(
"\$^{a = 10, N = 100, X = \\{+2, -1\\}, p \\textrm{\\ variando\\ } 0.001 \\textrm{\\ em\\ } (0,1)}\$"),
                 tickfont=6)
  display(analise)
end
main()
```

Estes gráficos ilustram essa inacurácia conforme $E(X)$ se aproxima de $0$ para um jogo com outras regras fixadas. Isto é
restrições do uso do estimador residem nas regras que levam a $E(X)$ próximo de $0$, uma vez que, conforme $E(X)$
se aproxima de $0$, sua presença no denominador provoca divergências quando comparado com o valor simulado.

Estudamos também como simplificar a variável aleatória de regras $X$ através de médias quando esta pode assumir mais
que dois valores.


## Conclusão e Passos Seguintes

Os resultados obtidos indicam que o estimador proposto possui grande flexibilidade para diferentes configurações do jogo
e mostra-se especialmente útil, pois as técnicas atuais não são capazes de fornecer um resultado teórico exato para as
configurações de jogos propostas. Ademais, o estimador fornece estimativas mais precisas quando há maior circulação de
dinheiro entre os jogadores. No entanto, observamos que o estimador tende a divergir rapidamente dos resultados simulados
quando a esperança da variável aleatória que rege as regras do jogo aproxima-se de zero devido ao denominador.

Outro desafio identificado foi a complexidade computacional envolvida na simulação de jogos com muitas regras, isto é,
quando a variável aleatória pode assumir um grande número de valores. Essa limitação impõe a necessidade de soluções mais
eficientes para lidar com cenários de alta complexidade, o que será um obstáculo a ser superado no estudo do caso não
homogêneo.

Um interessante caminho de abordagem que buscaremos explorar é a conexão entre passeios aleatórios e redes elétricas como descrito
por @doyle_random_1984. Queremos descobrir se existem conexões entre o estimador proposto e fórmulas da física, além de outras
abordagens para estudarmos passeios aleatórios, como o emprego de equações de diferenças finitas e o estudo de martingais para
viabilização do estimador nesses casos.

{{< pagebreak >}}

## Bibliografia

::: {#refs}
:::

{{< pagebreak >}}

## Apêndice A - Comparação de um mesmo algoritmo em Julia e Python {.appendix}

Para validar nossa decisão de trocarmos de linguagem, comparamos o mesmo (ingênuo) algoritmo em Julia e Python que usamos
para avaliarmos o estimador:

### Julia

```{julia}
using  LaTeXStrings, Random

function main()
  Random.seed!(1)
  duracoesSoma = 0
  M = 1_000_000
  p = 0.4
  teto = 100
  for i in 1:M
    saldo = 30
    duracao = 0
    while saldo > 0 && saldo < teto
      if p > rand()
        saldo += 2
      else
        saldo -= 1
      end
      duracao += 1
    end
    duracoesSoma += duracao
  end
  display(LaTeXString("Média da duração de \$$M\$ passeios:
                      \$$(round(duracoesSoma/M, digits = 2))\$"))
end

tempo = @elapsed main()
display(LaTeXString("Tempo de execução em segundos: $tempo"))
```
{{< pagebreak >}}

### Python

```python
import random
import time


def main():
    random.seed(1)
    duracoes = 0
    M = 1_000_000
    p = 0.4
    teto = 100
    for i in range(M):
        saldo = 30
        duracao = 0
        while saldo > 0 and saldo < teto:
            if p > random.random():
                saldo += 2
            else:
                saldo -= 1
            duracao += 1
        duracoes += duracao
    media = duracoes / M
    print(f"Média da duração de {M} passeios: {media:.2f}")
  

start_time = time.time()
main()
print(f"Tempo de execução: {time.time() - start_time} segundos")
```

```{julia}
#| echo: false

using PyCall, LaTeXStrings

py"""
def simulacao_py():
  import random
  import time

  def main():
      random.seed(1)
      duracoes = 0
      M = 1000000
      p = 0.4
      teto = 100
      for i in range(M):
          saldo = 30
          duracao = 0
          while saldo > 0 and saldo < teto:
              if p > random.random():
                  saldo += 2
              else:
                  saldo -= 1
              duracao += 1
          duracoes += duracao
      return duracoes / M
      # print(f"Média da duração de {M} passeios: {media:.2f}")
    

  start_time = time.time()
  return main()
  # print(f"Tempo de execução: {time.time() - start_time} segundos")
"""
a = @elapsed media = py"simulacao_py"()
display(LaTeXString("Média da duração de \$1000000\$ passeios: \$$(round(media, digits=2))\$"))
display(LaTeXString("Tempo de execução: $a segundos"))
```

Para a simulação em Python nesse artigo, foi utilizado a biblioteca PyCall que nos permite criar um ambiente Python no Julia,
possibilitando rodar código Python nessa linguagem o que foi necessário para inclusão de sua saída exata no relatório.
A performance pode ter sido afetada minimamente nos tempos de chamada ao Kernel de execução do Python.

### Decisão de mudança

Desconsiderando o curto tempo de compilação do tempo total do código em Julia, que só precisa ser
feito uma vez, temos que essa linguagem costuma ser considerávelmente mais rápida do que o Python, o que foi crucial nessas
simulações e justificou nossas mudanças como previsto por resultados anteriores de @godoy_evaluating_2023

## Apêndice B - Código de simulação com regras mais complexas

```{julia}
using Random, LaTeXStrings

function simulador(;a = 50, N = 100, X=[[1, 0.5],[-1, 0.5]], M=10_000, semente = nothing)
  if !isnothing(semente)
    Random.seed!(5)
  end
  duracoesSoma = 0

  for i in 1:M
    saldo = a
    duracao = 0
    while saldo > 0 && saldo < N
      p = rand()
      for x in X
        p -= x[2]
        if p < 0
          saldo += x[1]
          break
        end
      end
      duracao += 1
    end
    duracoesSoma += duracao
  end
  display(LaTeXString("Média da duração de \$$M\$ passeios:
                      \$$(round(duracoesSoma/M, digits = 2))\$"))
  return duracoesSoma / M
end
simulador(X=[[8, 0.6],[-2, 0.5]], semente = 1) # 4
simulador(X=[[6, 0.5],[4, 0.25], [-8, 0.25]], semente = 2) # 2 
simulador(X=[[2, 0.5],[6, 0.2], [-4, 0.3]], semente = 3) # 1
simulador(X=[[1, 0.5],[3, 0.2], [-2, 0.3]], semente = 4) # 0.5
simulador(X=[[-2, 0.5],[-6, 0.2], [4, 0.3]], semente = 5) # -1
simulador(X=[[5, 0.2],[-5, 0.8]], semente = 6) # -3
```

